# SciML Julia 风格指南

[![SciML Code Style](https://img.shields.io/static/v1?label=code%20style&message=SciML&color=9558b2&labelColor=389826)](https://github.com/SciML/SciMLStyle) [![Global Docs](https://img.shields.io/badge/docs-SciML-blue.svg)](https://docs.sciml.ai/SciMLStyle/stable/)

SciML 风格指南是适用于 Julia 编程语言的风格指南。 它被 [SciML 开源科学机器学习组织](https://sciml.ai/) 所使用。 因此，它在社区开放讨论。 请提交一个 issue 或开启一个 PR 来讨论对该风格指南的修改。

**目录**
- [SciML Julia 风格指南](#sciml-style-guide-for-julia)
  - [代码风格徽章](#code-style-badge)
  - [SciML 风格的总体原则](#overarching-dogmas-of-the-sciml-style)
    - [一致性与约定](#consistency-vs-adherence)
    - [社区贡献准则](#community-contribution-guidelines)
    - [开源贡献是从小到大的历练](#open-source-contributions-are-allowed-to-start-small-and-grow-over-time)
    - [使用通用化的代码](#generic-code-is-preferred-unless-code-is-known-to-be-specific)
    - [尽量匹配用户使用的类型](#internal-types-should-match-the-types-used-by-users-when-possible)
    - [尽可能使用 Trait 定义并遵循通用的接口](#trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible)
    - [应该限制使用宏，并只将其用于语法糖](#macros-should-be-limited-and-only-be-used-for-syntactic-sugar)
    - [尽可能捕获错误，并提供上下文信息以供参考](#errors-should-be-caught-as-high-as-possible-and-error-messages-should-be-contextualized-for-newcomers)
    - [优先使用子包和接口包，而不是通过 Requires.jl 使用条件模块](#subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-requiresjl)
    - [函数应该尽量避免分配内存并重复使用缓存，或者将输入视为不可变的](#functions-should-either-attempt-to-be-non-allocating-and-reuse-caches-or-treat-inputs-as-immutable)
    - [在性能足够的情况下，优先选择 Out-Of-Place 和不可变性](#out-of-place-and-immutability-is-preferred-when-sufficient-performant)
    - [测试应尽量覆盖广泛的输入类型范围](#tests-should-attempt-to-cover-a-wide-gamut-of-input-types)
    - [当存在疑虑时，子模块应该成为子包或独立包](#when-in-doubt-a-submodule-should-become-a-subpackage-or-separate-package)
    - [尽可能避免全局范围](#globals-should-be-avoided-whenever-possible)
    - [尽可能保证类型稳定且基于类型编程](#type-stable-and-type-grounded-code-is-preferred-wherever-possible)
    - [应尽量避免使用闭包](#closures-should-be-avoided-whenever-possible)
    - [数值功能应使用适当的通用数值接口](#numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces)
    - [函数应该包含一项基本原则](#functions-should-capture-one-underlying-principle)
    - [尽可能将内部选择作为选项暴露出来](#internal-choices-should-be-exposed-as-options-whenever-possible)
    - [尽可能重复使用代码而不是重复编写代码](#prefer-code-reuse-over-rewrites-whenever-possible)
    - [尽可能避免遮蔽函数](#prefer-to-not-shadow-functions)
    - [不要使用已经不维护的依赖](#avoid-unmaintained-dependencies)
  - [具体规则](#specific-rules)
    - [首要规则](#high-level-rules)
    - [通用命名原则](#general-naming-principles)
    - [注释](#comments)
    - [模块](#modules)
    - [函数](#functions)
    - [函数参数优先级](#function-argument-precedence)
    - [测试与持续集成](#tests-and-continuous-integration)
    - [空格](#whitespace)
    - [命名元组](#namedtuples)
    - [数值](#numbers)
    - [三元操作符](#ternary-operator)
    - [For 循环](#for-loops)
    - [函数类型标记](#function-type-annotations)
    - [结构类型标记](#struct-type-annotations)
    - [宏](#macros)
    - [类型与类型标记](#types-and-type-annotations)
    - [软件包版本规范](#package-version-specifications)
    - [文档](#documentation)
    - [错误处理](#error-handling)
    - [数组](#arrays)
    - [行尾](#line-endings)
    - [VS Code 设置](#vs-code-settings)
    - [JuliaFormatter](#juliaformatter)
- [参考](#references)


## 代码风格徽章

通过在你的 `README.md` 文件加上该徽章来让你的贡献者知道你的项目遵循了 SciML 代码风格。

```md
[![SciML Code Style](https://img.shields.io/static/v1?label=code%20style&message=SciML&color=9558b2&labelColor=389826)](https://github.com/SciML/SciMLStyle)
```

## SciML 风格的总体原则

### 一致性与遵守

正如 PEP8 所说：

> 风格指南关注的是一致性。 与该风格指南保持一致非常重要。 在一个项目中保持一致性更为重要。 在一个模块或函数内保持一致性最为重要。

> 但最重要的是：要知道何时可以不一致 —— 有时候风格指南并不适用。 当你有疑问时，请运用你的判断力。 看看其他的例子，决定哪个看起来最好。 不犹豫地向他人求助！

SciML 组织中的一些代码已经过时，处于维护状态，并由研究人员捐赠以进行维护。 一致性是首要目标，因此修改以符合风格指南的事，应该在整个仓库的基础上进行，不要仅更新一个文件以符合风格指南（而将其他文件保持不变）。

### 社区贡献准则

完整的社区贡献指南，请参考 [ColPrac](https://github.com/SciML/ColPrac)。 需要强调的一个相关要点是，一个 PR 应该只做一件事。 在风格上，这意味着更新软件包代码风格的 PR 不应与基本代码贡献混在一起。 这种分离使得更容易确保大规模的风格改进与实质性（可能引发破坏性）的代码更改相互独立。

### 开源贡献：从一步到千里

如果代码贡献的标准是每个 PR 都需要支持任何人能想到的所有可能的输入类型，那对于新手来说门槛就太高了。 相反，原则是一开始就尽可能正确，并随着时间的推移逐渐增加其通用性。 所有推荐的功能都应该经过测试，并且任何已知的普遍性问题都应该在一个 issue 中进行记录（并在可能的情况下使用 @test_broken 测试）。 然而，已知不与 GPU 兼容的函数并不是阻碍代码合并的理由，相反，我们鼓励后续的 PR 来改进通用类型的支持！

### 除非特定情况，使用通用的代码

例如，请看如下代码：

```julia
function f(A, B)
    for i in 1:length(A)
        A[i] = A[i] + B[i]
    end
end
```

出于两个原因，这种写法并不建议。 其中之一是，假定了 `A` 使用了基于单一索引的方法，而对于 [OffsetArrays](https://github.com/JuliaArrays/OffsetArrays.jl) 和 [FFTViews](https://github.com/JuliaArrays/FFTViews.jl) 的情况则会出现问题。 另外一个问题是，它需要索引，但并不是所有的数组类型都支持索引（例如 [CuArrays](https://github.com/JuliaGPU/CuArrays.jl)）。 更加通用且兼容性更好的实现方法是使用广播，例如：

```julia
function f(A, B)
    @. A = A + B
end
```

这将支持更广泛的数组类型。

### 尽可能使内部类型与用户使用的类型相匹配

如果 `f(A)` 接受某些集合作为输入，并从这些集合计算输出，那么可以期望如果用户将 `A` 作为 `Array` 传递，计算应该通过 `Array` 进行。 如果 `A` 是 `CuArray`，那么计算应该在内部使用 `CuArray` 进行（或者在不支持的情况下适当抛出错误）。 出于这些原因，在编写 `f` 时，通过类似 `similar(A)` 的通用方法构建数组优于使用非通用构造函数，例如 `Array(undef,size(A))`，除非该函数被记为非通用。

### 尽可能使用 Trait 定义并遵循通用的接口

Julia 提供了许多不同的接口，例如：

- [Iteration](https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration)
- [Indexing](https://docs.julialang.org/en/v1/manual/interfaces/#Indexing)
- [Broadcast](https://docs.julialang.org/en/v1/manual/interfaces/#man-interfaces-broadcasting)

这些接口应该尽可能被遵循。 例如，在定义广播重载时，应按照文档建议实现 `BroadcastStyle`，而不仅仅尝试通过 `copyto!` 重载来绕过广播系统。

当接口函数缺失时，这些函数应该添加到 Base Julia 或一个接口包，比如 [ArrayInterface.jl](https://github.com/JuliaArrays/ArrayInterface.jl)。 在适当的情况下，应声明并使用这些 traits。 例如，如果一行代码需要进行突变，应在尝试变化之前检查 trait `ArrayInterface.ismutable(A)`，并编写完善的错误消息来捕获其不可变的情况（或者提供一个不进行突变的替代代码）。

这一原则的一个例子就是 Jacobian 矩阵的生成。 在许多科研领域的应用程序，人们可能希望从用户输入的 `u0` 中生成 Jacobian 缓存。 生成 Jacobian 矩阵的一种天真的方法是 `J = similar(u0, length(u0), length(u0))`。 然而，这将生成一个 `J`，使得 `J` 是 `Matrix` 类型。

### 应该限制使用宏，并只将其用于语法糖

宏定义了新的语法，因此相对于其他编码风格，它们往往不太能组合，并且需要事先熟悉才能容易理解。 一个要记住的原则是：“读代码的人能否轻松地想象出生成的代码是什么？”。 例如，Soss.jl 的用户可能不知道以下代码生成了什么样的代码：

```julia
@model (x, α) begin
    σ ~ Exponential()
    β ~ Normal()
    y ~ For(x) do xj
        Normal(α + β * xj, σ)
    end
    return y
end
```

因此，不建议使用这样的宏作为接口。 然而，像 [`@muladd`](https://github.com/SciML/MuladdMacro.jl) 这样的宏在代码中很容易理解（它递归地将 `a*b + c` 转换为 `muladd(a,b,c)`，以提高[准确性和效率](https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation)），因此可以使用这样的宏，例如：

```julia
julia> @macroexpand(@muladd k3 = f(t + c3 * dt, @. uprev + dt * (a031 * k1 + a032 * k2)))
:(k3 = f((muladd)(c3, dt, t), (muladd).(dt, (muladd).(a032, k2, (*).(a031, k1)), uprev)))
```

这种写法是推荐的。 其中一些这类宏包括：

- `@inbounds`
- [`@muladd`](https://github.com/SciML/MuladdMacro.jl)
- `@view`
- [`@named`](https://github.com/SciML/ModelingToolkit.jl)
- `@.`
- [`@..`](https://github.com/YingboMa/FastBroadcast.jl)

一些性能宏，如 `@simd`、`@threads` 或者来自 LoopVectorization.jl 的 [`@turbo`](https://github.com/JuliaSIMD/LoopVectorization.jl)，在这方面有个例外，它们生成的代码可能对许多用户来说是陌生的。 然而，它们仍然被归类为适当的用法，因为它们只是语法糖，除了性能之外，它们不会（或者不应该）以可测定的方式改变程序的行为。

### 尽可能捕获错误，并提供上下文信息以供参考

尽可能使用防御性编程在遇到潜在错误之前进行检查，以避免它们在包的更深层次出现。 例如，如果我们知道，除非 `u0` 的大小与 `p` 相同，否则 `f(u0,p)` 会出错，那么在函数的开始处应该捕获这个错误，并抛出一个特定作用域的错误，例如“参数和初始条件应该具有相同的大小”。

错误信息的上下文应该使用与用户界面 API 相关的术语（而不是引用内部实现细节）。  理想情况下，这样的错误消息不仅应该用用户熟悉的语言描述问题，而且在可能的情况下，还应包含如何纠正问题的建议。

### 优先使用子包和接口包，而不是通过 Requires.jl 使用条件模块

应该不惜一切代价避免使用 Requireres.jl。 如果存在接口包，例如用于定义自动微分规则而无需依赖整个 ChainRules.jl 系统的 [ChainRulesCore.jl](https://github.com/JuliaDiff/ChainRulesCore.jl)，或者用于定义 Plots.jl 绘图方式而无需依赖 Plots.jl 的 [RecipesBase.jl](https://github.com/JuliaPlots/RecipesBase.jl)，则更倾向于直接依赖这种接口包。

否则，与其使用 Requires.jl 进行条件依赖，更倾向于创建子软件包，即在同一 GitHub 仓库中保留的较小的独立软件包，具有独立的版本控制和软件包管理。 这一点可以在 [Optimization.jl](https://github.com/SciML/Optimization.jl) 中看到，它有像 [OptimizationBBO.jl](https://github.com/SciML/Optimization.jl/tree/master/lib/OptimizationBBO) 这样的子软件包，用于支持 BlackBoxOptim.jl。

需要了解的一些重要接口包有：

- [ChainRulesCore.jl](https://github.com/JuliaDiff/ChainRulesCore.jl)
- [RecipesBase.jl](https://github.com/JuliaPlots/RecipesBase.jl)
- [ArrayInterface.jl](https://github.com/JuliaArrays/ArrayInterface.jl)
- [CommonSolve.jl](https://github.com/SciML/CommonSolve.jl)
- [SciMLBase.jl](https://github.com/SciML/SciMLBase.jl)

### 函数应该尽量避免分配内存并重复使用缓存，或者将输入视为不可变的

可变代码和不可变代码属于完全不同的世界。 当代码完全不可变时，编译器可以更好地跟踪依赖关系，优化代码，并检查其是否正确。 然而，很多时候，充分利用可变的代码甚至可以超越当今最好的编译器所生成的代码。 话虽如此，最糟糕的情况就是将可变代码与不可变代码混在一起。 这不仅是一种编码风格的混合，还可能导致潜在的非局部性和编译器校验问题，因为它在不充分利用可变性的同时进行了可变代码的编写。

### 在性能足够的情况下，优先选择 Out-Of-Place 和不可变性

通过减少堆分配的数量，可变性可以提高性能。 然而，如果对于给定点的堆分配没有好处，那么就不要使用可变性。 除非可变性可以带来直接的好处，不然这些可怕的可变性应该尽可能避免。 例如，如果矩阵足够大，那么 `A*B` 的速度与 `mul!(C,A,B)` 是相当的，因此，更倾向于编写 `A*B`（除非函数的其余部分很注重完全的非内存分配，为了一致性就应该使用 `mul!`）。

类似地，在定义类型时，除非结构体的变化是普遍的，否则更倾向于使用 `struct` 而不是 `mutable struct`。 即使结构体的变化是常见情况，也要看看是否可以仅使用 [Setfield.jl](https://github.com/jw3126/Setfield.jl) 来实现。 编译器会对不可变结构体的构建进行优化，因此如果这么写不会太麻烦，代码会更加高效。

### 测试应尽量覆盖广泛的输入类型范围

如果不考虑输入类型，代码覆盖率数字就毫无意义。 例如，可以使用 `Array` 覆盖所有代码，但这并不能确认 `CuArray` 是否兼容！ 因此，应该将类型覆盖率作为代码覆盖率的重要部分，而不是仅仅关注代码行数。 对于数值，以下几种类型最好是要考虑的：

- `Float64`
- `Float32`
- `Complex`
- [`Dual`](https://github.com/JuliaDiff/ForwardDiff.jl)
- `BigFloat`

对于数组则是：

- `Array`
- [`OffsetArray`](https://github.com/JuliaArrays/OffsetArrays.jl)
- [`CuArray`](https://github.com/JuliaGPU/CUDA.jl)

### 当存在疑虑时，子模块应该成为子包或独立包

一个包应该只集中在做好一件事情。 如果有些代码足够独立，以至于可以作为一个子模块，那么是否可以将它们独立出来，进行全面的测试并编写文档，以便其他的包使用？ 大多数情况下，是的。

### 尽可能避免全局范围

应该尽可能避免使用全局变量。 一定需要时，全局变量应该是常量，并且用下划线隔开的大写字母命名（例如，`MY_CONSTANT`）。 它们需要在文件的开始，在导入和导出之后，`__init__` 函数之前被定义。 如果你真的希望使用可变的全局行为，你可能需要考虑使用可变容器。

### 尽可能保证类型稳定且基于类型编程

类型的稳定以及基于类型的编写的代码，不仅可以使编译器生成高度优化的代码，同时可以提高编译速度。 始终保持容器具有良好的类型定义，函数只专注于适当的参数，并确保类型具体明确。

### 应尽量避免使用闭包

闭包可能会导致难以追踪和调试的类型不稳定性；从长远来看，以防御性编程为准则，并在首次编写代码时避免使用闭包。即使某个闭包可能并不会引起问题，这样做也能节省时间。 类似的论点也适用于阅读带有闭包的代码；如果有人正在寻找类型不稳定性，不含闭包的代码更方便搜查。 此外，如果你想要在外部作用域中更新变量，可以明确地使用 `Ref` 或自定义的结构体来实现。 例如：
```julia
map(Base.Fix2(getindex, i), vector_of_vectors)
```
该写法比以下两种写法要好：
```julia
map(v -> v[i], vector_of_vectors)
```
或
```julia
[v[i] for v in vector_of_vectors]
```

### 数值功能应使用适当的通用数值接口

虽然你可以在包内使用 `A\b` 进行线性求解，但这并不意味着你应该这样做。 这个接口仅适用于执行因式分解，因此降低了可扩展性、以及 `A` 的类型的兼容性。 相反，在软件包内的进行线性解析，应该使用 LinearSolve.jl。 同样的，非线性解析应该使用 NonlinearSolve.jl。 编码优化应该使用 Optimization.jl。 诸如此类。 这样可以将完全通用的选择权交给用户，而无需依赖每个求解器包（在每个包内重新创建通用接口）。

### 函数应该包含一项基本原则

函数意味着一件事。 每次调用 `+` 都代表着“在这些类型上做加法”。 虽然理论上你可以添加不同含义的 `+` 用法，但在以 `+` 表示加法的通用代码中，这会造成错误。 为了使通用代码正常工作，代码需要遵循每个函数的一个含义。 每次调用都应该是该含义的一个实例化。

### 尽可能将内部选择作为选项暴露出来

在可能的情况下，脚本中的数值和选择应该作为选项向用户公开。 在超出作者预期的一些情况下，这可以提高代码的可重复使用性。

### 尽可能重复使用代码而不是重复编写代码

如果一个软件包里含有一个你需要的函数，请使用软件包。 在需要的时候添加一个依赖。 如果函数缺少一个功能，倾向于使用这样的软件包作为依赖来实现。 如果这个依赖有一些潜在的问题，比如它的加载时间很长，考虑花一些时间帮助该软件包解决这些问题，最后再作为依赖。 只有你不可能帮助这个包变得“足够好”的情况下，你才应该放弃使用它。 如果你放弃了这个包，你可以考虑为你所需要的功能构建一个新的软件包，并使它可以成为其他项目的一个依赖。

### 尽可能避免遮蔽函数

在 Julia 中，两个函数可以通过不同的命名空间来使用相同的函数名。 例如，`X.f` 和 `Y.f` 可以是两个不同的函数，具有不同的调用方式，但名称却相同。 当然，这种情况应该尽可能避免。 比起创建一个 `MyPackage.sort`，在你想要添加的新用法符合基本函数的原则时，你应该为你的类型将这些用法添加到 `Base.sort` 中。 如果不是，考虑使用不同的函数名称。 虽然使用 `MyPackage.sort` 并不会产生冲突，但对于大多数不熟悉你的代码的人来说，这可能会令人困惑，因此考虑到一些阅读代码的新手，使用 `MyPackage.special_sort` 会更方便他人熟悉。

### 不要使用已经不维护的依赖

只有当包的维护者能够及时作出响应时，才应该依赖于这些包。 好的代码需要好的社区。 如果它的维护者在被多次提醒时，两周内仍未对问题做出回应，那么应考虑移除依赖性中所有该组织的包。 注意，有些问题可能需要远超过两周时间才能解决，重要的是保持沟通的开放性、一致性和及时性。

## 具体规则

### 首要规则

- 使用 4 个空格缩进，不使用 Tab。
- 尝试保证每行的字符在 92 个之内。

### 通用命名原则

- 所有的类型名称都应该是 `CamelCase`。
- 所有的结构名称都应该是 `CamelCase`。
- 所有的模块名称都应该是 `CamelCase`。
- 所有的函数名称都应该是 `snake_case`（全部小写）。
- 所有的变量名称都应该是 `snake_case`（全部小写）。
- 所有的常量名称都应该是 `snake_case`（全部小写）。
- 所有抽象类型名称都应该以 `Abstract` 开头。
- 所有类型的变量名称应只有一个大写字母，词义最好与所表示的值相关联。
- 整个单词通常要比使用缩写和单个字母好。
- 用于表示包内部或私有的变量应该以两个下划线作为前缀，即 `__`。
- 在为数学实体命名时，使用单个字母可能是可以接受的，即该实体的目的或非数学的“含义”可能只有下游调用者知道。 例如，在实现 `*(a::AbstractMatrix, b::AbstractMatrix)` 时，名称 `a` 和 `b` 是合适的，因为这些参数的“含义”（除了它们作为矩阵的数学含义，已经由类型描述）只有调用者知道。
- 在代码中使用 Unicode 来提高可读性是可以的，但在任何情况下，都不应该在公共 API 中使用 Unicode。 这是为了支持无法使用 Unicode 的终端而设定的：如果一个关键字参数必须是 η，那么在不支持 Unicode 输入的集群上使用它可能会被排除。

### 注释

- 使用 `TODO` 来标记待办注释，使用 `XXX` 来标记对当前有问题代码的注释。
- 在注释中使用反引号（例如，`` `variable_name` ``）引用代码。
- 如果可能的话，应该修改部分代码以包含本会在注释中体现的信息。 比如，比起使用 `# fx applies the effects to a tree`，仅仅把函数名改为 `apply_effects(tree)` 就足够了。
- 指向 GitHub issues 和 PRs 的注释应该包含对应的 URL。 只有当内联注释符合行长度限制时才使用内联注释。 如果你的注释无法放在一行内，那么将注释放置在所涉及内容的上方：

```julia
# Yes:

# Number of nodes to predict. Again, an issue with the workflow order. Should be updated
# after data is fetched.
p = 1

# No:

p = 1  # Number of nodes to predict. Again, an issue with the workflow order. Should be
# updated after data is fetched.
```

- 一般而言，我们更倾向于将注释放置在代码行或函数之上，而非使用内联注释。

### 模块

- 模块应该在文件的开头或在一个 `module` 的定义后导入。
- 在包中，模块导入应该使用 `import` 关键字或明确声明导入的功能，例如 `using Dates: Year, Month, Week, Day, Hour, Minute, Second, Millisecond`。
- `import` 和 `using` 语句应该分开，并用一个空行分隔。

```julia
# Yes:
import A: a
import C

using B
using D: d

# No:
import A: a
using B
import C
using D: d
```

- 大量的导入项应该在行内使用逗号分隔编写。

```julia
# Yes:
using A, B, C, D

# No:
using A
using B
using C
using D

# No:
using A,
      B,
      C,
      D
```

- 导出的变量应该被视为公共 API 的一部分，对它们的接口的改变视为破坏性改动。
- 任何导出变量都应该是唯一的。 换句话说，不要导出如 `f` 这样的名称，这很可能与其他代码发生冲突。
- 包含模块定义的文件不应包含任何在该模块之外运行的其他代码。 也就是说，该模块应在文件顶部使用关键字 `module` 声明，并在文件底部使用 `end` 结束。 除了模块文档字符串之前的部分，不应该有其他代码出现在其前后。 在这种情况下，模块块内的代码应该**不**缩进。
- 有时候，例如用于测试或为了给枚举命名空间，希望在文件的中部声明一个子模块。 在这种情况下，模块块内的代码应该**应该**缩进。

### Functions

- Only use short-form function definitions when they fit on a single line:

```julia
# Yes:
foo(x::Int64) = abs(x) + 3

# No:
foobar(array_data::AbstractArray{T}, item::T) where {T <: Int64} = T[
    abs(x) * abs(item) + 3 for x in array_data
]
```

- Inputs should be required unless a default is historically expected or likely to be applicable to >95% of use cases. For example, the tolerance of a differential equation solver was set to a default of `abstol=1e-6,reltol=1e-3` as a generally correct plot in most cases, and is an expectation from back in the 90's. In that case, using the historically expected and most often useful default tolerances is justified. However, if one implements `GradientDescent`, the learning rate needs to be adjusted for each application (based on the size of the gradient), and thus a default of `GradientDescent(learning_rate = 1)` is not recommended.
- Arguments that do not have defaults should preferably be made into positional arguments. The newer syntax of required keyword arguments can be useful, but should not be abused. Notable exceptions are cases where "either or" arguments are accepted, for example, if defining `g` or `dgdu` is sufficient, then making them both keyword arguments with `= nothing` and checking that either is not `nothing` (and throwing an appropriate error) is recommended if distinct dispatches with different types is not possible.
- When calling a function, always separate your keyword arguments from your positional arguments with a semicolon. This avoids mistakes in ambiguous cases (such as splatting a Dict).
- When writing a function that sends a lot of keyword arguments to another function, say sending keyword arguments to a differential equation solver, use a named tuple keyword argument instead of splatting the keyword arguments. For example, use `diffeq_solver_kwargs = (; abstol=1e-6, reltol=1e-6,)` as the API and use `solve(prob, alg; diffeq_solver_kwargs...)` instead of splatting all keyword arguments.
- Functions that mutate arguments should be appended with `!`.
- [Avoid type piracy](https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy). I.e., do not add methods to functions you don't own on types you don't own. Either own the types or the function.
- Functions should prefer instances instead of types for arguments. For example, for a solver type `Tsit5`, the interface should use `solve(prob,Tsit5())`, not `solve(prob,Tsit5)`. The reason for this is multifold. For one, passing a type has different specialization rules, so functionality can be slower unless `::Type{Tsit5}` is written in the dispatches that use it. Secondly, this allows for default and keyword arguments to extend the choices, which may become useful for some types down the line. Using this form allows for adding more options in a non-breaking manner.
- If the number of arguments is too large to fit into a 92 character line, then use as many arguments as possible within a line and start each new row with the same indentation, preferably at the same column as the `(` but this can be moved left if the function name is very long. For example:

```julia
# Yes
function my_large_function(argument1, argument2,
                           argument3, argument4,
                           argument5, x, y, z)

# No
function my_large_function(argument1,
                           argument2,
                           argument3,
                           argument4,
                           argument5,
                           x,
                           y,
                           z)
```


### Function Argument Precedence

1. **Function argument**. Putting a function argument first permits the use of [`do`](https://docs.julialang.org/en/v1/base/base/#do) blocks for passing multiline anonymous functions.

2. **I/O stream**. Specifying the `IO` object first permits passing the function to functions such as [`sprint`](https://docs.julialang.org/en/v1/base/io-network/#Base.sprint), e.g. `sprint(show, x)`.

3. **Input being mutated**. For example, in [`fill!(x, v)`](https://docs.julialang.org/en/v1/base/arrays/#Base.fill!), `x` is the object being mutated and it appears before the value to be inserted into `x`.

4. **Type**. Passing a type typically means that the output will have the given type. In [`parse(Int, "1")`](https://docs.julialang.org/en/v1/base/numbers/#Base.parse), the type comes before the string to parse. There are many such examples where the type appears first, but it's useful to note that in [`read(io, String)`](https://docs.julialang.org/en/v1/base/io-network/#Base.read), the `IO` argument appears before the type, which is in keeping with the order outlined here.

5. **Input not being mutated**. In `fill!(x, v)`, `v` is *not* being mutated and it comes after `x`.

6. **Key**. For associative collections, this is the key of the key-value pair(s). For other indexed collections, this is the index.

7. **Value**. For associative collections, this is the value of the key-value pair(s). In cases like [`fill!(x, v)`](https://docs.julialang.org/en/v1/base/arrays/#Base.fill!), this is `v`.

8. **Everything else**. Any other arguments.

9. **Varargs**. This refers to arguments that can be listed indefinitely at the end of a function call. For example, in `Matrix{T}(undef, dims)`, the dimensions can be given as a [`Tuple`](https://docs.julialang.org/en/v1/base/base/#Core.Tuple), e.g. `Matrix{T}(undef, (1,2))`, or as [`Vararg`](https://docs.julialang.org/en/v1/base/base/#Core.Vararg)s, e.g. `Matrix{T}(undef, 1, 2)`.

10. **Keyword arguments**. In Julia keyword arguments have to come last anyway in function definitions; they're listed here for the sake of completeness.

The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be used for any applicable arguments to a function.

### Tests and Continuous Integration

- The high level `runtests.jl` file should only be used to shuttle to other test files.
- Every set of tests should be included into a [`@safetestset`](https://github.com/YingboMa/SafeTestsets.jl). A standard `@testset` does not fully enclose all defined values, such as functions defined in a `@testset`, and thus can "leak".
- Test includes should be written in one line, for example:

```julia
@time @safetestset "Jacobian Tests" include("interface/jacobian_tests.jl")
```

- Every test script should be fully reproducible in isolation. I.e., one should be able to copy paste that script and receive the results.
- Test scripts should be grouped based on categories, for example tests of the interface vs tests for numerical convergence. Grouped tests should be kept in the same folder.
- A `GROUP` environment variable should be used to specify test groups for parallel testing in continuous integration. A fallback group `All` should be used to specify all the tests that should be run when a developer runs `]test Package` locally. As an example, see the [OrdinaryDiffEq.jl test structure](https://github.com/SciML/OrdinaryDiffEq.jl/blob/v6.10.0/test/runtests.jl)
- Tests should include downstream tests to major packages which use the functionality, to ensure continued support. Any update that breaks the downstream tests should follow with a notification to the downstream package of why the support was broken (preferably in the form of a PR that fixes support), and the package should be given a major version bump in the next release if the changed functionality was part of the public API.
- CI scripts should use the default settings unless required.
- CI scripts should test the Long-Term Support (LTS) release and the current stable release. Nightly tests are only necessary for packages with a heavy reliance on specific compiler details.
- Any package supporting GPUs should include continuous integration for GPUs.
- [Doctests](https://juliadocs.github.io/Documenter.jl/stable/man/doctests/) should be enabled except for the examples that are computationally-prohibitive to have as part of continuous integration.

### Whitespace

- Avoid extraneous whitespace immediately inside parentheses, square brackets or braces.

    ```julia
    # Yes:
    spam(ham[1], [eggs])

    # No:
    spam( ham[ 1 ], [ eggs ] )
    ```

- Avoid extraneous whitespace immediately before a comma or semicolon:

    ```julia
    # Yes:
    if x == 4 @show(x, y); x, y = y, x end

    # No:
    if x == 4 @show(x , y) ; x , y = y , x end
    ```

- Avoid whitespace around `:` in ranges. Use brackets to clarify expressions on either side.

    ```julia
    # Yes:
    ham[1:9]
    ham[9:-3:0]
    ham[1:step:end]
    ham[lower:upper-1]
    ham[lower:upper - 1]
    ham[lower:(upper + offset)]
    ham[(lower + offset):(upper + offset)]

    # No:
    ham[1: 9]
    ham[9 : -3: 1]
    ham[lower : upper - 1]
    ham[lower + offset:upper + offset]  # Avoid as it is easy to read as `ham[lower + (offset:upper) + offset]`
    ```

- Avoid using more than one space around an assignment (or other) operator to align it with another:

    ```julia
    # Yes:
    x = 1
    y = 2
    long_variable = 3

    # No:
    x             = 1
    y             = 2
    long_variable = 3
    ```

- Surround most binary operators with a single space on either side: assignment (`=`), [updating operators](https://docs.julialang.org/en/v1/manual/mathematical-operations/#Updating-operators-1) (`+=`, `-=`, etc.), [numeric comparisons operators](https://docs.julialang.org/en/v1/manual/mathematical-operations/#Numeric-Comparisons-1) (`==`, `<`, `>`, `!=`, etc.), [lambda operator](https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions-1) (`->`). Binary operators may be excluded from this guideline include: the [range operator](https://docs.julialang.org/en/v1/base/math/#Base.::) (`:`), [rational operator](https://docs.julialang.org/en/v1/base/math/#Base.://) (`//`), [exponentiation operator](https://docs.julialang.org/en/v1/base/math/#Base.:^-Tuple{Number,%20Number}) (`^`), [optional arguments/keywords](https://docs.julialang.org/en/v1/manual/functions/#Optional-Arguments-1) (e.g. `f(x = 1; y = 2)`).

    ```julia
    # Yes:
    i = j + 1
    submitted += 1
    x^2 < y

    # No:
    i=j+1
    submitted +=1
    x^2<y
    ```

- Avoid using whitespace between unary operands and the expression:

    ```julia
    # Yes:
    -1
    [1 0 -1]

    # No:
    - 1
    [1 0 - 1]  # Note: evaluates to `[1 -1]`
    ```

- Avoid extraneous empty lines. Avoid empty lines between single line method definitions and otherwise separate functions with one empty line, plus a comment if required:

    ```julia
    # Yes:
    # Note: an empty line before the first long-form `domaths` method is optional.
    domaths(x::Number) = x + 5
    domaths(x::Int) = x + 10
    function domaths(x::String)
        return "A string is a one-dimensional extended object postulated in string theory."
    end

    dophilosophy() = "Why?"

    # No:
    domath(x::Number) = x + 5

    domath(x::Int) = x + 10



    function domath(x::String)
        return "A string is a one-dimensional extended object postulated in string theory."
    end


    dophilosophy() = "Why?"
    ```

- Function calls that cannot fit on a single line within the line limit should be broken up such that the lines containing the opening and closing brackets are indented to the same level while the parameters of the function are indented one level further. In most cases, the arguments and/or keywords should each be placed on separate lines. Note that this rule conflicts with the typical Julia convention of indenting the next line to align with the open bracket in which the parameter is contained. If working in a package with a different convention, follow the convention used in the package over using this guideline.

    ```julia
    # Yes:
    f(a, b)
    constraint = conic_form!(SOCElemConstraint(temp2 + temp3, temp2 - temp3, 2 * temp1),
                             unique_conic_forms)

    # No:
    # Note: `f` call is short enough to be on a single line
    f(
        a,
        b,
    )
    constraint = conic_form!(SOCElemConstraint(temp2 + temp3,
                                               temp2 - temp3, 2 * temp1),
                             unique_conic_forms)
    ```

- Group similar one line statements together.

    ```julia
    # Yes:
    foo = 1
    bar = 2
    baz = 3

    # No:
    foo = 1

    bar = 2

    baz = 3
    ```

- Use blank-lines to separate different multi-line blocks.

    ```julia
    # Yes:
    if foo
        println("Hi")
    end

    for i in 1:10
        println(i)
    end

    # No:
    if foo
        println("Hi")
    end
    for i in 1:10
        println(i)
    end
    ```
- After a function definition, and before an end statement do not include a blank line.

    ```julia
    # Yes:
    function foo(bar::Int64, baz::Int64)
        return bar + baz
    end

    # No:
    function foo(bar::Int64, baz::Int64)

        return bar + baz
    end

    # No:
    function foo(bar::In64, baz::Int64)
        return bar + baz

    end
    ```

- Use line breaks between control flow statements and returns.

    ```julia
    # Yes:
    function foo(bar; verbose = false)
        if verbose
            println("baz")
        end

        return bar
    end

    # Ok:
    function foo(bar; verbose = false)
        if verbose
            println("baz")
        end
        return bar
    end
    ```

### NamedTuples

The `=` character in `NamedTuple`s should be spaced as in keyword arguments. Space should be put between the name and its value. The empty `NamedTuple` should be written `NamedTuple()` not `(;)`

```julia
# Yes:
xy = (x = 1, y = 2)
x = (x = 1,)  # Trailing comma required for correctness.
x = (; kwargs...)  # Semicolon required to splat correctly.

# No:
xy = (x=1, y=2)
xy = (;x=1,y=2)
```

### Numbers

- Floating-point numbers should always include a leading and/or trailing zero:

```julia
# Yes:
0.1
2.0
3.0f0

# No:
.1
2.
3.f0
```

- Always prefer the type `Int` to `Int32` or `Int64` unless one has a specific reason to choose the bit size.

### Ternary Operator

Ternary operators (`?:`) should generally only consume a single line. Do not chain multiple ternary operators. If chaining many conditions, consider using an `if`-`elseif`-`else` conditional, dispatch, or a dictionary.

```julia
# Yes:
foobar = foo == 2 ? bar : baz

# No:
foobar = foo == 2 ?
    bar :
    baz
foobar = foo == 2 ? bar : foo == 3 ? qux : baz
```

As an alternative, you can use a compound boolean expression:

```julia
# Yes:
foobar = if foo == 2
    bar
else
    baz
end

foobar = if foo == 2
    bar
elseif foo == 3
    qux
else
    baz
end
```

### For loops

For loops should always use `in`, never `=` or `∈`. This also applies to list and generator comprehensions

```julia
# Yes
for i in 1:10
    #...
end

[foo(x) for x in xs]

# No:
for i = 1:10
    #...
end

[foo(x) for x ∈ xs]
```

### Function Type Annotations

Annotations for function definitions should be as general as possible.

```julia
# Yes:
splicer(arr::AbstractArray, step::Integer) = arr[begin:step:end]

# No:
splicer(arr::Array{Int}, step::Int) = arr[begin:step:end]
```

Using as many generic types as possible allows for a variety of inputs and allows your code to be more general:

```julia
julia> splicer(1:10, 2)
1:2:9

julia> splicer([3.0, 5, 7, 9], 2)
2-element Array{Float64,1}:
 3.0
 7.0
```

### Struct Type Annotations

Annotations on type fields need to be given a little more thought, since field access is not concrete unless the compiler can infer the type (see [type-dispatch design](https://www.stochasticlifestyle.com/type-dispatch-design-post-object-oriented-programming-julia/) for details). Since well-inferred code is preferred, abstract type annotations, i.e.

```julia
mutable struct MySubString <: AbstractString
    string::AbstractString
    offset::Integer
    endof::Integer
end
```

are not recommended. Instead a concretely-typed struct:

```julia
mutable struct MySubString <: AbstractString
    string::String
    offset::Int
    endof::Int
end
```

is preferred. If generality is required, then parametric typing is preferred, i.e.:

```julia
mutable struct MySubString{T<:Integer} <: AbstractString
    string::String
    offset::T
    endof::T
end
```

Untyped fields should be explicitly typed `Any`, i.e.:

```julia
struct StructA
    a::Any
end
```

### Macros

- Do not add spaces between assignments when there are multiple assignments.

```julia
Yes:
@parameters a = b
@parameters a=b c=d

No:
@parameters a = b c = d
```

### Types and Type Annotations

- Avoid elaborate union types. `Vector{Union{Int,AbstractString,Tuple,Array}}` should probably be `Vector{Any}`. This will reduce the amount of extra strain on compilation checking many branches.
- Unions should be kept to two or three types only for branch splitting. Unions of three types should be kept to a minimum for compile times.
- Do not use `===` to compare types. Use `isa` or `<:` instead.

### Package version specifications

- Use [Semantic Versioning](https://semver.org/)
- For simplicity, avoid including the default caret specifier when specifying package version requirements.

```julia
# Yes:
DataFrames = "0.17"

# No:
DataFrames = "^0.17"
```

- For accuracy, do not use constructs like `>=` to avoid upper bounds.
- Every dependency should have a bound.
- All packages should use [CompatHelper](https://github.com/JuliaRegistries/CompatHelper.jl) and attempt to stay up to date with the dependencies.
- The lower bound on dependencies should be the last tested version.

### Documentation

- Documentation should always attempt to be at the highest level possible. I.e., documentation of an interface that all methods follow is preferred to documenting every method, and documenting the interface of an abstract type is preferred to documenting all the subtypes individually. All instances should then refer to the higher level documentation.
- Documentation should use [Documenter.jl](https://juliadocs.github.io/Documenter.jl/stable/).
- Tutorials should come before reference materials.
- Every package should have a starting tutorial that covers "the 90% use case", i.e. the ways that most people will want to use the package.
- The tutorial should show a complete workflow and be opinionated about said workflow. For example, when writing a tutorial about a simulator, pick a plotting package and show how to plot it.
- Variable names in tutorials are important. If you use `u0`, then all other codes will copy that naming scheme. Show potential users the right way to use your code with the right naming.
- When applicable, tutorials on how to use the "high performance advanced features" should be separated from the beginning tutorial.
- All documentation should summarize the contents before going into specifics of API docstrings.
- Most modules, types and functions should have [docstrings](http://docs.julialang.org/en/v1/manual/documentation/).
- Prefer documenting accessor functions instead of fields when possible. Documented fields are part of the public API and changing their contents/name constitutes a breaking change.
- Only exported functions are required to be documented.
- Avoid documenting commonly overloaded methods, such as `==`.
- Try to document a function and not individual methods where possible, as typically all methods will have similar docstrings.
- If you are adding a method to a function that already has a docstring only add a docstring if the behavior of your function deviates from the existing docstring.
- Docstrings are written in [Markdown](https://en.wikipedia.org/wiki/Markdown) and should be concise.
- Docstring lines should be wrapped at 92 characters.

```julia
"""
    bar(x[, y])

Compute the Bar index between `x` and `y`. If `y` is missing, compute the Bar index between
all pairs of columns of `x`.
"""
function bar(x, y) ...
```

- It is recommended that you have a blank line between the headings and the content when the content is of sufficient length.
- Try to be consistent within a docstring whether you use this additional whitespace.
- Follow one of the following templates for types and functions when possible:

Type Template (should be skipped if it is redundant with the constructor(s) docstring):

```julia
"""
    MyArray{T, N}

My super awesome array wrapper!

# Fields
- `data::AbstractArray{T, N}`: stores the array being wrapped
- `metadata::Dict`: stores metadata about the array
"""
struct MyArray{T, N} <: AbstractArray{T, N}
    data::AbstractArray{T, N}
    metadata::Dict
end
```

Function Template (only required for exported functions):

```julia
"""
    mysearch(array::MyArray{T}, val::T; verbose = true) where {T} -> Int

Searches the `array` for the `val`. For some reason we don't want to use Julia's
builtin search :)

# Arguments
- `array::MyArray{T}`: the array to search
- `val::T`: the value to search for

# Keywords
- `verbose::Bool = true`: print out progress details

# Returns
- `Int`: the index where `val` is located in the `array`

# Throws
- `NotFoundError`: I guess we could throw an error if `val` isn't found.
"""
function mysearch(array::AbstractArray{T}, val::T) where {T}
    ...
end
```

- The `@doc doc""" """` formulation from the Markdown standard library should be used whenever there is LaTeX.
- Only public fields of types must be documented. Undocumented fields are considered non-public internals.
- If your method contains lots of arguments or keywords, you may want to exclude them from the method signature on the first line and instead use `args...` and/or `kwargs...`.

```julia
"""
    Manager(args...; kwargs...) -> Manager

A cluster manager which spawns workers.

# Arguments

- `min_workers::Integer`: The minimum number of workers to spawn or an exception is thrown
- `max_workers::Integer`: The requested number of workers to spawn

# Keywords

- `definition::AbstractString`: Name of the job definition to use. Defaults to the
    definition used within the current instance.
- `name::AbstractString`: ...
- `queue::AbstractString`: ...
"""
function Manager(...)
    ...
end
```

- Feel free to document multiple methods for a function within the same docstring. Be careful to only do this for functions you have defined.

```julia
"""
    Manager(max_workers; kwargs...)
    Manager(min_workers:max_workers; kwargs...)
    Manager(min_workers, max_workers; kwargs...)

A cluster manager which spawns workers.

# Arguments

- `min_workers::Int`: The minimum number of workers to spawn or an exception is thrown
- `max_workers::Int`: The requested number of workers to spawn

# Keywords

- `definition::AbstractString`: Name of the job definition to use. Defaults to the
    definition used within the current instance.
- `name::AbstractString`: ...
- `queue::AbstractString`: ...
"""
function Manager end

```

- If the documentation for bullet-point exceeds 92 characters, the line should be wrapped and slightly indented. Avoid aligning the text to the `:`.

```julia
"""
...

# Keywords
- `definition::AbstractString`: Name of the job definition to use. Defaults to the
    definition used within the current instance.
"""
```

### Error Handling

- `error("string")` should be avoided. Defining and throwing exception types is preferred. See the [manual on exceptions for more details](https://docs.julialang.org/en/v1/manual/control-flow/#Exception-Handling).
- Try to avoid `try/catch`. Use it as minimally as possible. Attempt to catch potential issues before running code, not after.

### Arrays

- Avoid splatting (`...`) whenever possible. Prefer iterators such as `collect`, `vcat`, `hcat`, etc. instead.

### Line Endings

Always use Unix style `\n` line ending.

### VS-Code Settings

If you are a user of VS Code we recommend that you have the following options in your Julia syntax specific settings. To modify these settings, open your VS Code Settings with <kbd>CMD</kbd>+<kbd>,</kbd> (Mac OS) or <kbd>CTRL</kbd>+<kbd>,</kbd> (other OS), and add to your `settings.json`:

```json
{
    "[julia]": {
        "editor.detectIndentation": false,
        "editor.insertSpaces": true,
        "editor.tabSize": 4,
        "files.insertFinalNewline": true,
        "files.trimFinalNewlines": true,
        "files.trimTrailingWhitespace": true,
        "editor.rulers": [92],
        "files.eol": "\n"
    },
}
```
Additionally, you may find the [Julia VS-Code plugin](https://github.com/julia-vscode/julia-vscode) useful.

### JuliaFormatter

**Note: the** `sciml` **style is only available in** `JuliaFormatter v1.0` **or later**

One can add `.JuliaFormatter.toml` with the content
```toml
style = "sciml"
```
in the root of a repository, and run
```julia
using JuliaFormatter, SomePackage
format(joinpath(dirname(pathof(SomePackage)), ".."))
```
to format the package automatically.

Add [FormatCheck.yml](https://github.com/SciML/ModelingToolkit.jl/blob/master/.github/workflows/FormatCheck.yml) to enable the formatting CI. The CI will fail if the repository needs additional formatting. Thus, one should run `format` before committing.

# References

Many of these style choices were derived from the [Julia style guide](https://docs.julialang.org/en/v1/manual/style-guide/), the [YASGuide](https://github.com/jrevels/YASGuide), and the [Blue style guide](https://github.com/invenia/BlueStyle#module-imports).
