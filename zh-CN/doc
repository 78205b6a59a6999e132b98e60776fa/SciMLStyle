# SciML Julia 风格指南

[![SciML Code Style](https://img.shields.io/static/v1?label=code%20style&message=SciML&color=9558b2&labelColor=389826)](https://github.com/SciML/SciMLStyle) [![Global Docs](https://img.shields.io/badge/docs-SciML-blue.svg)](https://docs.sciml.ai/SciMLStyle/stable/)

SciML 风格指南是适用于 Julia 编程语言的风格指南。 它被 [SciML 开源科学机器学习组织](https://sciml.ai/) 所使用。 因此，它在社区开放讨论。 请提交一个 issue 或开启一个 PR 来讨论对该风格指南的修改。

**目录**
- [SciML Julia 风格指南](#sciml-style-guide-for-julia)
  - [代码风格徽章](#code-style-badge)
  - [SciML 风格的总体原则](#overarching-dogmas-of-the-sciml-style)
    - [一致性与约定](#consistency-vs-adherence)
    - [社区贡献准则](#community-contribution-guidelines)
    - [开源贡献是从小到大的历练](#open-source-contributions-are-allowed-to-start-small-and-grow-over-time)
    - [使用通用化的代码](#generic-code-is-preferred-unless-code-is-known-to-be-specific)
    - [尽可能匹配用户使用的类型](#internal-types-should-match-the-types-used-by-users-when-possible)
    - [尽可能使用合适的 Trait 及通用的接口](#trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible)
    - [仅在作为语法糖的情况下使用宏](#macros-should-be-limited-and-only-be-used-for-syntactic-sugar)
    - [尽可能捕获具有完善上下文的错误信息](#errors-should-be-caught-as-high-as-possible-and-error-messages-should-be-contextualized-for-newcomers)
    - [优先使用子包和接口包，而不是 Requires.jl](#subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-requiresjl)
    - [函数应减少分配内存并重用缓存，或使用不可变的输入](#functions-should-either-attempt-to-be-non-allocating-and-reuse-caches-or-treat-inputs-as-immutable)
    - [性能足够高时，首选 Out-of-Place 和不可变性的写法](#out-of-place-and-immutability-is-preferred-when-sufficient-performant)
    - [测试应该囊括尽可能多的输入类型](#tests-should-attempt-to-cover-a-wide-gamut-of-input-types)
    - [子模块应该适时改写为子包或独立包](#when-in-doubt-a-submodule-should-become-a-subpackage-or-separate-package)
    - [尽可能避免使用全局作用域](#globals-should-be-avoided-whenever-possible)
    - [尽可能基于类型编程并保持类型稳定](#type-stable-and-type-grounded-code-is-preferred-wherever-possible)
    - [尽可能避免使用闭包](#closures-should-be-avoided-whenever-possible)
    - [数值有关的功能应使用适当且通用的数值接口](#numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces)
    - [函数意义的原则](#functions-should-capture-one-underlying-principle)
    - [尽可能将编码时的考虑作为用户可用的选项](#internal-choices-should-be-exposed-as-options-whenever-possible)
    - [尽可能重复使用代码](#prefer-code-reuse-over-rewrites-whenever-possible)
    - [尽可能避免遮蔽函数](#prefer-to-not-shadow-functions)
    - [不使用不再维护的依赖](#avoid-unmaintained-dependencies)
  - [具体规则](#specific-rules)
    - [首要规则](#high-level-rules)
    - [通用命名原则](#general-naming-principles)
    - [注释](#comments)
    - [模块](#modules)
    - [函数](#functions)
    - [函数参数优先级](#function-argument-precedence)
    - [测试与持续集成](#tests-and-continuous-integration)
    - [空格](#whitespace)
    - [命名元组](#namedtuples)
    - [数值](#numbers)
    - [三元操作符](#ternary-operator)
    - [For 循环](#for-loops)
    - [函数类型标记](#function-type-annotations)
    - [结构类型标记](#struct-type-annotations)
    - [宏](#macros)
    - [类型与类型标记](#types-and-type-annotations)
    - [软件包版本规范](#package-version-specifications)
    - [文档](#documentation)
    - [错误处理](#error-handling)
    - [数组](#arrays)
    - [行尾](#line-endings)
    - [VS Code 设置](#vs-code-settings)
    - [JuliaFormatter](#juliaformatter)
- [参考](#references)


## 代码风格徽章

在你的项目的 `README.md` 文件中加上这个徽章，让参与你项目的同伴知道此项目遵守了 SciML 代码风格！

```md
[![SciML Code Style](https://img.shields.io/static/v1?label=code%20style&message=SciML&color=9558b2&labelColor=389826)](https://github.com/SciML/SciMLStyle)
```

## SciML 风格的总体原则

### 一致性与约定

正如 Python 的 PEP 8 所说：

> 风格指南是有关一致性的准则。 代码与该风格指南保持一致性很重要， 在整个项目的尺度下保持一致性更为重要， 而最重要的是在一个模块或函数内保持风格的一致性。

> 此外，不可或缺的是：知晓何时打破一致性 —— 因为风格指南并非无所不能。 当你陷入选择写法的困境，请仔细思考判断。 参考其他案例，并采取可能最好的方案。 并且，不要耻于提问！

SciML 组织中的有一些仍受支持的过时代码，由研究人员捐赠并加以维护。 保持风格的一致性是首要目标，因此应该在整个代码库的水平上作出修改以符合风格指南，而不仅仅是更新一个文件。

### 社区贡献准则

你可以查看 [ColPrac](https://github.com/SciML/ColPrac) 获取完整的社区贡献指南。 其中，需要强调的是，一个 PR 应该只做一件事。 也就是，更新软件包代码风格的 PR 不应与基本代码的贡献混在一起。 这种拆分使得大规模的风格改进，和可能引发不定性结果的实质性代码修改，得以互不干涉。

### 开源贡献是从小到大的历练

如果评判贡献代码好坏的标准，是任何一个 PR 都需要考虑到所有人的所有想法；那么这会在维护者和新的参与者之间划出一道鸿沟。 比起严格的要求，原则上只需要在一开始尽可能做到正确，随时间推移，慢慢增加代码的通用性即可。 所有建议的功能都需要通过测试，并且任何已知的普遍存在问题都需要被记录在 issue 中（如果可以的话，使用 `@test_broken` 测试）。 不过，比如 PR 中存在一个不与 GPU 兼容的函数，则不能因为这个函数无法通过测试而阻止合并，相反，这将激励同伴们提交下一个 PR 来改进该函数的支持。

### 优先使用通用化的代码

例如以下代码：

```julia
function f(A, B)
    for i in 1:length(A)
        A[i] = A[i] + B[i]
    end
end
```

以上写法有两个缺陷。 其一，该函数假定了 `A` 使用了基于 “1” 的索引方法，而对于 [OffsetArrays](https://github.com/JuliaArrays/OffsetArrays.jl) 和 [FFTViews](https://github.com/JuliaArrays/FFTViews.jl) 的用例则会出现问题。 其二，该函数需要使用索引，但并不是所有的数组类型都支持索引（例如 [CuArrays](https://github.com/JuliaGPU/CuArrays.jl)）。 对此，通用且兼容性更好的实现方法是使用广播，例如：

```julia
function f(A, B)
    @. A = A + B
end
```

使用广播，将支持更多的数组类型。

### 尽可能匹配用户使用的类型

如果 `f(A)` 以某些集合作为输入，并使用这些集合的内容进行计算。那么，理想情况下，如果用户传入的 `A` 是一个 `Array` 对象，那么函数内的计算应该通过 `Array` 进行。 如果 `A` 是一个 `CuArray` 对象，那么应该使用 `CuArray` 进行计算（或在不支持的情况下抛出错误）。 因此，在你编写 `f` 时，使用类似 `similar(A)` 的通用方法构建数组，优于使用诸如 `Array(undef,size(A))` 这类非通用的构造函数。除非你明确这个函数在文档中已经说明了它的不通用性。

### 尽可能使用 Trait 定义并遵循通用的接口

Julia 提供了许多不同的接口，例如：

- [Iteration](https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration)
- [Indexing](https://docs.julialang.org/en/v1/manual/interfaces/#Indexing)
- [Broadcast](https://docs.julialang.org/en/v1/manual/interfaces/#man-interfaces-broadcasting)

应该尽可能使用这些接口。 例如，在定义广播重载时，应按照文档的建议实现 `BroadcastStyle`，而不是通过 `copyto!` 重载来绕过广播机制。

当缺少接口函数时，应该把相关功能的函数添加到 Base Julia 中或创建一个接口包，就像 [ArrayInterface.jl](https://github.com/JuliaArrays/ArrayInterface.jl) 所做的一样。 Traits 应该在合适的时候声明并使用： 例如，如果一行代码需要数组可变，应该先检查 trait `ArrayInterface.ismutable(A)`，如果该数组是不可变的，应该抛出完善的错误信息（或者提供一个不要求可变的代码版本）。

举个例子：雅可比（Jacobian）矩阵的生成。 在许多科研领域的应用，可能需要从用户输入的 `u0` 中生成雅可比（Jacobian）缓存。 你可能天真地以为，可以用 `J = similar(u0, length(u0), length(u0))` 生成雅可比（Jacobian）矩阵。 但这样生成的雅可比（Jacobian） 矩阵 J 却会是一个 Matrix 类型的矩阵

### 仅在作为语法糖的情况下使用宏

宏定义了新的语法，因此它们往往比其他编码风格更难以组合，并且需要事先熟悉才能理解。 你应该拷问自己：你能否让你的阅读者想象出你生成了什么代码？ 例如，Soss.jl 的用户可能不知道以下代码生成了什么：

```julia
@model (x, α) begin
    σ ~ Exponential()
    β ~ Normal()
    y ~ For(x) do xj
        Normal(α + β * xj, σ)
    end
    return y
end
```

因此，尽可能不要使用这种宏作为接口。 不过，像 [`@muladd`](https://github.com/SciML/MuladdMacro.jl) 这样的宏在代码中很容易理解（它能[准确且高效](https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation)地使用递归将 `a*b + c` 转换为 `muladd(a,b,c)`），因此可以使用这样的宏，例如：

```julia
julia> @macroexpand(@muladd k3 = f(t + c3 * dt, @. uprev + dt * (a031 * k1 + a032 * k2)))
:(k3 = f((muladd)(c3, dt, t), (muladd).(dt, (muladd).(a032, k2, (*).(a031, k1)), uprev)))
```

我们推荐使用上述写法。 同类的宏包括：

- `@inbounds`
- [`@muladd`](https://github.com/SciML/MuladdMacro.jl)
- `@view`
- [`@named`](https://github.com/SciML/ModelingToolkit.jl)
- `@.`
- [`@..`](https://github.com/YingboMa/FastBroadcast.jl)

一些性能相关的宏，如 `@simd`、`@threads` 或者来自 LoopVectorization.jl 的 [`@turbo`](https://github.com/JuliaSIMD/LoopVectorization.jl) 是例外，它们生成的代码可能对大部分用户来说是陌生的。 然而，这些写法是合理的，因为它们只是语法糖：除了性能之外，它们不会（或者不应该）以可测定的方式改变程序的行为。

### 尽可能捕获具有完善上下文的错误信息

使用防御性编程检查潜在的错误，避免它们出现在软件包的更深层次。 例如，存在一个函数 `f(u0,p)`，如果 `u0` 的大小与 `p` 不同，函数会出错。那么你应该在函数开始时就检查这个潜在问题，并适时抛出一个该作用域的错误，指出 “参数（parameters）和初始条件（initial condition）应该大小一致”。

你应该在错误信息中输出用户所知道的 API 术语，而不是指向内部的实现细节。  在使用用户熟悉的语言描述清楚问题的同时，最好包含一些解决问题的建议。

### 优先使用子包和接口包，而不是 Requires.jl

尽可能地避免使用 Requires.jl。 倾向于使用你需要的某个特定的接口包。例如，要定义自动微分规则，你只需要依赖 [ChainRulesCore.jl](https://github.com/JuliaDiff/ChainRulesCore.jl) 而不用依赖整个 ChainRules.jl 系统；要定义 Plots.jl 的 recipes 你只需要使用 [RecipesBase.jl](https://github.com/JuliaPlots/RecipesBase.jl) 而不用使用整个 Plots.jl。

否则，比起使用 Requires.jl 进行条件依赖，你应该创建一个子软件包；换句话说，在同一个 GitHub 仓库里保存一份具有独立版本控制和包管理的独立软件包。 例如，在 [Optimization.jl](https://github.com/SciML/Optimization.jl) 中，[OptimizationBBO.jl](https://github.com/SciML/Optimization.jl/tree/master/lib/OptimizationBBO) 这样的子软件包，用于支持 BlackBoxOptim.jl。

一些你最好要知道的接口包有：

- [ChainRulesCore.jl](https://github.com/JuliaDiff/ChainRulesCore.jl)
- [RecipesBase.jl](https://github.com/JuliaPlots/RecipesBase.jl)
- [ArrayInterface.jl](https://github.com/JuliaArrays/ArrayInterface.jl)
- [CommonSolve.jl](https://github.com/SciML/CommonSolve.jl)
- [SciMLBase.jl](https://github.com/SciML/SciMLBase.jl)

### 函数应减少分配内存并重用缓存，或使用不可变的输入

可变（Mutating）代码和不可变（Non-Mutating）代码仿佛是两个完全不同的世界。 当你的代码完全不可变（Immutable）时，编译器可以更好的推断依赖关系，优化代码并检查错误。 然而有些时候，充分利用可变（Mutation）的代码，甚至可以超越当今最好的编译器所生成的代码。 尽管如此，当你混合两种模式的代码时，结果会变得很糟糕。 这不只仅仅是一种编码风格的混合，还会导致潜在的非局部性（Non-locality）和编译器校验问题，这是因为这些代码没有充分利用好可变性。

### 性能足够高时，首选 Out-of-Place 和不可变性的写法

可变性（Mutation）可以通过减少堆的分配（Heap Allocations）来提高性能， 然而，在特定情况下，如果进行堆的分配没有帮助，就不要使用可变性（Mutation）写法， 除非可变性可以带来立竿见影的效果。 例如，在矩阵足够大的情况下，`A*B` 与 `mul!(C,A,B)` 的速度是相当的，此时，更倾向于编写 `A*B`（除非函数的其他部分严格地不进行内存分配，为了一致性就应该写作 `mul!`）。

类似的，除非结构（Struct）的变化是普遍需要的，否则更倾向于使用 `struct` 而不是 `mutable struct`； 即使结构（Struct）的变化是普遍的，你也要尽可能使用 [Setfield.jl](https://github.com/jw3126/Setfield.jl) 来实现。 因为编译器会对不可变（Immutable）的结构进行优化，所以不嫌麻烦的话，尽可能书写不可变的代码，这使得你的程序更加高效。

### 测试应该囊括尽可能多的输入类型

如果不考虑输入类型，代码覆盖率的数字就毫无意义。 例如，你可以使用 `Array` 覆盖所有代码，但这不会检测 `CuArray` 的兼容性。 因此，类型覆盖率应该作为一个重要的覆盖率指标，而不是仅仅取决于行数。 对于数值，最好考虑以下几种类型：

- `Float64`
- `Float32`
- `Complex`
- [`Dual`](https://github.com/JuliaDiff/ForwardDiff.jl)
- `BigFloat`

对于数组则是：

- `Array`
- [`OffsetArray`](https://github.com/JuliaArrays/OffsetArrays.jl)
- [`CuArray`](https://github.com/JuliaGPU/CUDA.jl)

### 子模块应该适时改写为子包或独立包

一个软件包应该只做好一件事。 如果有些代码足够独立，以至于可以单独作为一个子模块； 那么你应该考虑将它们独立出来，进行完善的测试并编写文档，以便其他包使用。

### 尽可能避免使用全局作用域

尽可能避免使用全局作用域。 当不得不使用全局作用域时，全局变量应该是常量，并且用下划线隔开的大写字母命名（例如，`MY_CONSTANT`）， 并将它们的定义放在文件的开始，在导入与导出之后，在 `__init__` 函数之前。 如果你真的要使用可变（Mutable）的全局操作，你应该考虑使用可变容器（Mutable Container）。

### 尽可能基于类型编程并保持类型稳定

基于类型编程并保持类型稳定，不仅可以使编译器生成高度优化的代码，同时也可以提高编译速度。 你需要保证容器（Containers）具有准确的类型定义，保证函数只处理适当的参数，保证类型始终具体且明确。

### 尽可能避免使用闭包

闭包可能会使不稳定的类型问题难以被追踪和调试；长远来看，出于防御性编程的目的，你应该在一开始就尽可能避免使用闭包。纵使一些闭包可能不会引起问题，但这么做也可以节省时间。 类似情景也存在于阅读带有闭包的代码的过程；如果有人在追踪不稳定的类型问题，不含闭包的代码显然更方便调试。 如果你想要在外部作用域中更新变量，可以明确地使用 `Ref` 或自定义的结构（Struct）来实现。 例如：
```julia
map(Base.Fix2(getindex, i), vector_of_vectors)
```
这种写法要优于以下两种：
```julia
map(v -> v[i], vector_of_vectors)
```
或
```julia
[v[i] for v in vector_of_vectors]
```

### 数值有关的功能应使用适当且通用的数值接口

虽然你可以在包内使用 `A\b` 进行线性求解，但这并不意味着你应该这样做。 这个接口仅适用于执行因式分解，因此该写法降低了可扩展性、以及 `A` 的类型的兼容性。 相反，在包内的进行线性解析，应该使用 LinearSolve.jl； 同样的，非线性解析应该使用 NonlinearSolve.jl； 编码优化方面应该使用 Optimization.jl； 诸如此类。 这将给予用户完整的通用的选择，而无需再依赖每个求解器（Solver）包，其实质是在每个包内重新创建一个通用的接口。

### 函数意义的原则

一个函数做一件事。 每次调用 `+` 都代表着“在指定的类型上做加法”。 虽然理论上你可以添加不同含义的 `+` 用法，但在以 `+` 表示加法的通用代码语境中，这是不合适的。 为了使通用的代码运作良好，你需要考虑每个函数的意义。 每次调用函数都应该是其含义的实例化。

### 尽可能将编码时的考虑作为用户可用的选项

你应该尽可能地将你在编程时考虑的多种数值和方法，作为代码的选项暴露给用户使用。 这可能会带来一些意想不到的代码的重复使用。

### 尽可能重复使用代码

如果一个软件包里含有一个你需要的函数，那就使用这个软件包， 并将其作为一个依赖。 如果该函数缺少某个功能，建议为该软件包添加这个功能，再把它作为依赖。 如果这个依赖有一些潜在的问题，比如它的加载速度很慢，你应该考虑帮助该软件包解决这个问题，最后再将它作为依赖。 只有你不可能帮助这个包变得“足够好”的情况下，你才应该放弃使用它。 如果你放弃了一个包，你应该考虑为你所需要的功能构建一个新的包。

### 尽可能避免遮蔽函数

在 Julia 中，在不同命名空间里的两个函数可以使用相同的函数名。 例如，`X.f` 和 `Y.f` 是两个不同的函数，具有不同的调用方式，但名称却相同。 当然，这种情况应该尽可能避免。 比起创建一个 `MyPackage.sort`，当你想要添加的新用法符合基本函数的原则时，你应该为你的类型将这些用法添加到 `Base.sort` 中。 如果不符合，考虑使用不同的函数名称。 虽然使用 `MyPackage.sort` 并不会产生冲突，但对于大多数不熟悉你的代码的人来说，这可能会令人困惑，因此考虑到一些阅读代码的新手，使用 `MyPackage.special_sort` 会更方便他人熟悉。

### 不使用不再维护的依赖

只有当包的维护者能够及时作出响应时，才应该依赖于这些包。 好的代码需要好的社区。 如果它的维护者在被多次提醒时，两周内仍未对问题做出任何回应，那么应该考虑移除所使用的该组织的所有依赖项。 注意，有些问题可能需要远超两周的时间才能解决，重要的维护者要保持沟通的开放性、一致性和及时性。

## 具体规则

### 首要规则

- 使用 4 个空格缩进，不使用 Tab。
- 每行的字符应在 92 个之内。

### 通用命名原则

- 类型名称应该使用 `驼峰式命名法`。
- 结构名称应该使用 `驼峰式命名法`。
- 模块名称应该使用 `驼峰式命名法`。
- 函数名称应该使用 `蛇形命名法`（全部小写）。
- 变量名称应该使用 `蛇形命名法`（全部小写）。
- 常量名称应该使用 `蛇形命名法`（全部大写）。
- 抽象类型名称应该以 `Abstract` 开头。
- 所有类型变量名称应该以唯一的大写字母开头，且根据语义化命名。
- 使用完整的单词而不是缩写。
- 用于表示包内部或私有的变量应该以两个下划线作为前缀，即 `__`。
- 在为数学实体（Mathematical Entity）命名时，可以使用单个字母，因为该实体的目的和意义只有下游调用者才知道。 例如，在实现 `*(a::AbstractMatrix, b::AbstractMatrix)` 时，名称 `a` 和 `b` 都是合适的，因为这些参数的“含义”（除了作为已经由类型描述的矩阵的数学含义），只有调用者知道。
- 在代码中使用 Unicode 来提高可读性是可以的，但在任何情况下，都不应该在公共 API 中使用 Unicode。 这是为了支持无法使用 Unicode 的终端而设定的：如果一个关键字参数必须是 η，那么在不支持 Unicode 输入的集群上使用它可能会被忽略。

### 注释

- 使用 `TODO` 来标记待办注释，使用 `XXX` 来标记对当前有问题代码的注释。
- 在注释中使用反引号（例如，`` `variable_name` ``）引用代码。
- 考虑使用代码本身来体现一些原本应该在注释里体现的信息（语义化）。 例如，比起使用 `# fx applies the effects to a tree`，仅仅把函数名改为 `apply_effects(tree)` 就足够了。
- 指向 GitHub issues 和 PRs 的注释应该包含对应的 URL。 只有当行内注释符合行长度限制时才可以使用行内注释。 如果你的注释无法放在一行内，那么将注释放置在所涉及内容的上方：

```julia
# Yes:

# Number of nodes to predict. Again, an issue with the workflow order. Should be updated
# after data is fetched.
p = 1

# No:

p = 1  # Number of nodes to predict. Again, an issue with the workflow order. Should be
# updated after data is fetched.
```

- 一般而言，我们更倾向于将注释放置在代码行或函数之上，而不使用行内注释。

### 模块

- 模块应该在文件的开头或在一个 `module` 的定义后导入。
- 在包中，模块导入应该使用 `import` 关键字或明确声明导入的功能，例如 `using Dates: Year, Month, Week, Day, Hour, Minute, Second, Millisecond`。
- `import` 和 `using` 语句应该分开，并用一个空行分隔。

```julia
# Yes:
import A: a
import C

using B
using D: d

# No:
import A: a
using B
import C
using D: d
```

- 大量的导入项应该在行内使用逗号分隔进行导入。

```julia
# Yes:
using A, B, C, D

# No:
using A
using B
using C
using D

# No:
using A,
      B,
      C,
      D
```

- 导出的变量应该被视为公共 API 的一部分，对它们的接口的改变视为破坏性改动。
- 任何导出变量都应该是唯一的。 换句话说，不要导出如 `f` 这样的名称，这很可能与其他代码发生冲突。
- 包含模块定义的文件不应包含任何在该模块之外运行的代码。 也就是说，该模块应在文件开始使用关键字 `module` 声明，并在文件底部使用 `end` 结尾。 除可能存在的模块之前的文档字符外，模块的前后不应该有其他代码。 在这种情况下，模块的块内代码应该**不**缩进。
- 某些时候出于测试或为了给枚举命名空间，需要在文件的中部声明一个子模块。 在这种情况下，模块的块内代码应该**应该**缩进。

### 函数

- 当函数适合写在一行内时使用短函数（Short-form Function）形式。

```julia
# Yes:
foo(x::Int64) = abs(x) + 3

# No:
foobar(array_data::AbstractArray{T}, item::T) where {T <: Int64} = T[
    abs(x) * abs(item) + 3 for x in array_data
]
```

- 函数应该要求输入参数，除非提供历史上广受认可的默认值，或确保默认值在 > 95% 的情况下都是合适的。 例如，大多数情况下，微分方程求解器的容差默认值为 `abstol=1e-6、reltol=1e-3`，这是从 90 年代开始就普遍认可的绘图参数。 在这种情况下，使用历史承认、或最常用的值作为默认值是合理的。 然而，如果实现了 `GradientDescent`（梯度下降）算法，学习率（Learning Rate）需要根据每个应用程序进行调整（基于梯度的大小），因此不建议使用默认值，如 `GradientDescent(learning_rate = 1)`。
- 没有默认值的参数应该被作为位置参数。 新的必填关键词参数语法或许有所帮助，但不应该滥用。 Notable exceptions are cases where "either or" arguments are accepted, for example, if defining `g` or `dgdu` is sufficient, then making them both keyword arguments with `= nothing` and checking that either is not `nothing` (and throwing an appropriate error) is recommended if distinct dispatches with different types is not possible.
- When calling a function, always separate your keyword arguments from your positional arguments with a semicolon. This avoids mistakes in ambiguous cases (such as splatting a Dict).
- When writing a function that sends a lot of keyword arguments to another function, say sending keyword arguments to a differential equation solver, use a named tuple keyword argument instead of splatting the keyword arguments. For example, use `diffeq_solver_kwargs = (; abstol=1e-6, reltol=1e-6,)` as the API and use `solve(prob, alg; diffeq_solver_kwargs...)` instead of splatting all keyword arguments.
- Functions that mutate arguments should be appended with `!`.
- [Avoid type piracy](https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy). I.e., do not add methods to functions you don't own on types you don't own. Either own the types or the function.
- Functions should prefer instances instead of types for arguments. For example, for a solver type `Tsit5`, the interface should use `solve(prob,Tsit5())`, not `solve(prob,Tsit5)`. The reason for this is multifold. For one, passing a type has different specialization rules, so functionality can be slower unless `::Type{Tsit5}` is written in the dispatches that use it. Secondly, this allows for default and keyword arguments to extend the choices, which may become useful for some types down the line. Using this form allows for adding more options in a non-breaking manner.
- If the number of arguments is too large to fit into a 92 character line, then use as many arguments as possible within a line and start each new row with the same indentation, preferably at the same column as the `(` but this can be moved left if the function name is very long. For example:

```julia
# Yes
function my_large_function(argument1, argument2,
                           argument3, argument4,
                           argument5, x, y, z)

# No
function my_large_function(argument1,
                           argument2,
                           argument3,
                           argument4,
                           argument5,
                           x,
                           y,
                           z)
```


### Function Argument Precedence

1. **Function argument**. Putting a function argument first permits the use of [`do`](https://docs.julialang.org/en/v1/base/base/#do) blocks for passing multiline anonymous functions.

2. **I/O stream**. Specifying the `IO` object first permits passing the function to functions such as [`sprint`](https://docs.julialang.org/en/v1/base/io-network/#Base.sprint), e.g. `sprint(show, x)`.

3. **Input being mutated**. For example, in [`fill!(x, v)`](https://docs.julialang.org/en/v1/base/arrays/#Base.fill!), `x` is the object being mutated and it appears before the value to be inserted into `x`.

4. **Type**. Passing a type typically means that the output will have the given type. In [`parse(Int, "1")`](https://docs.julialang.org/en/v1/base/numbers/#Base.parse), the type comes before the string to parse. There are many such examples where the type appears first, but it's useful to note that in [`read(io, String)`](https://docs.julialang.org/en/v1/base/io-network/#Base.read), the `IO` argument appears before the type, which is in keeping with the order outlined here.

5. **Input not being mutated**. In `fill!(x, v)`, `v` is *not* being mutated and it comes after `x`.

6. **Key**. For associative collections, this is the key of the key-value pair(s). For other indexed collections, this is the index.

7. **Value**. For associative collections, this is the value of the key-value pair(s). In cases like [`fill!(x, v)`](https://docs.julialang.org/en/v1/base/arrays/#Base.fill!), this is `v`.

8. **Everything else**. Any other arguments.

9. **Varargs**. This refers to arguments that can be listed indefinitely at the end of a function call. For example, in `Matrix{T}(undef, dims)`, the dimensions can be given as a [`Tuple`](https://docs.julialang.org/en/v1/base/base/#Core.Tuple), e.g. `Matrix{T}(undef, (1,2))`, or as [`Vararg`](https://docs.julialang.org/en/v1/base/base/#Core.Vararg)s, e.g. `Matrix{T}(undef, 1, 2)`.

10. **Keyword arguments**. In Julia keyword arguments have to come last anyway in function definitions; they're listed here for the sake of completeness.

The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be used for any applicable arguments to a function.

### Tests and Continuous Integration

- The high level `runtests.jl` file should only be used to shuttle to other test files.
- Every set of tests should be included into a [`@safetestset`](https://github.com/YingboMa/SafeTestsets.jl). A standard `@testset` does not fully enclose all defined values, such as functions defined in a `@testset`, and thus can "leak".
- Test includes should be written in one line, for example:

```julia
@time @safetestset "Jacobian Tests" include("interface/jacobian_tests.jl")
```

- Every test script should be fully reproducible in isolation. I.e., one should be able to copy paste that script and receive the results.
- Test scripts should be grouped based on categories, for example tests of the interface vs tests for numerical convergence. Grouped tests should be kept in the same folder.
- A `GROUP` environment variable should be used to specify test groups for parallel testing in continuous integration. A fallback group `All` should be used to specify all the tests that should be run when a developer runs `]test Package` locally. As an example, see the [OrdinaryDiffEq.jl test structure](https://github.com/SciML/OrdinaryDiffEq.jl/blob/v6.10.0/test/runtests.jl)
- Tests should include downstream tests to major packages which use the functionality, to ensure continued support. Any update that breaks the downstream tests should follow with a notification to the downstream package of why the support was broken (preferably in the form of a PR that fixes support), and the package should be given a major version bump in the next release if the changed functionality was part of the public API.
- CI scripts should use the default settings unless required.
- CI scripts should test the Long-Term Support (LTS) release and the current stable release. Nightly tests are only necessary for packages with a heavy reliance on specific compiler details.
- Any package supporting GPUs should include continuous integration for GPUs.
- [Doctests](https://juliadocs.github.io/Documenter.jl/stable/man/doctests/) should be enabled except for the examples that are computationally-prohibitive to have as part of continuous integration.

### Whitespace

- Avoid extraneous whitespace immediately inside parentheses, square brackets or braces.

    ```julia
    # Yes:
    spam(ham[1], [eggs])

    # No:
    spam( ham[ 1 ], [ eggs ] )
    ```

- Avoid extraneous whitespace immediately before a comma or semicolon:

    ```julia
    # Yes:
    spam(ham[1], [eggs])

    # No:
    spam( ham[ 1 ], [ eggs ] )
    ```

- Avoid whitespace around `:` in ranges. Use brackets to clarify expressions on either side.

    ```julia
    # Yes:
    ham[1:9]
    ham[9:-3:0]
    ham[1:step:end]
    ham[lower:upper-1]
    ham[lower:upper - 1]
    ham[lower:(upper + offset)]
    ham[(lower + offset):(upper + offset)]

    # No:
    ham[1: 9]
    ham[9 : -3: 1]
    ham[lower : upper - 1]
    ham[lower + offset:upper + offset]  # Avoid as it is easy to read as `ham[lower + (offset:upper) + offset]`
    ```

- Avoid using more than one space around an assignment (or other) operator to align it with another:

    ```julia
    # Yes:
    x = 1
    y = 2
    long_variable = 3

    # No:
    x             = 1
    y             = 2
    long_variable = 3
    ```

- Surround most binary operators with a single space on either side: assignment (`=`), [updating operators](https://docs.julialang.org/en/v1/manual/mathematical-operations/#Updating-operators-1) (`+=`, `-=`, etc.), [numeric comparisons operators](https://docs.julialang.org/en/v1/manual/mathematical-operations/#Numeric-Comparisons-1) (`==`, `<`, `>`, `!=`, etc.), [lambda operator](https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions-1) (`->`). Binary operators may be excluded from this guideline include: the [range operator](https://docs.julialang.org/en/v1/base/math/#Base.::) (`:`), [rational operator](https://docs.julialang.org/en/v1/base/math/#Base.://) (`//`), [exponentiation operator](https://docs.julialang.org/en/v1/base/math/#Base.:^-Tuple{Number,%20Number}) (`^`), [optional arguments/keywords](https://docs.julialang.org/en/v1/manual/functions/#Optional-Arguments-1) (e.g. `f(x = 1; y = 2)`).

    ```julia
    # Yes:
    i = j + 1
    submitted += 1
    x^2 < y

    # No:
    i=j+1
    submitted +=1
    x^2<y
    ```

- Avoid using whitespace between unary operands and the expression:

    ```julia
    # Yes:
    -1
    [1 0 -1]

    # No:
    - 1
    [1 0 - 1]  # Note: evaluates to `[1 -1]`
    ```

- Avoid extraneous empty lines. Avoid empty lines between single line method definitions and otherwise separate functions with one empty line, plus a comment if required:

    ```julia
    # Yes:
    # Note: an empty line before the first long-form `domaths` method is optional.
    domaths(x::Number) = x + 5
    domaths(x::Int) = x + 10
    function domaths(x::String)
        return "A string is a one-dimensional extended object postulated in string theory."
    end

    dophilosophy() = "Why?"

    # No:
    domath(x::Number) = x + 5

    domath(x::Int) = x + 10



    function domath(x::String)
        return "A string is a one-dimensional extended object postulated in string theory."
    end


    dophilosophy() = "Why?"
    ```

- Function calls that cannot fit on a single line within the line limit should be broken up such that the lines containing the opening and closing brackets are indented to the same level while the parameters of the function are indented one level further. In most cases, the arguments and/or keywords should each be placed on separate lines. Note that this rule conflicts with the typical Julia convention of indenting the next line to align with the open bracket in which the parameter is contained. If working in a package with a different convention, follow the convention used in the package over using this guideline.

    ```julia
    # Yes:
    f(a, b)
    constraint = conic_form!(SOCElemConstraint(temp2 + temp3, temp2 - temp3, 2 * temp1),
                             unique_conic_forms)

    # No:
    # Note: `f` call is short enough to be on a single line
    f(
        a,
        b,
    )
    constraint = conic_form!(SOCElemConstraint(temp2 + temp3,
                                               temp2 - temp3, 2 * temp1),
                             unique_conic_forms)
    ```

- Group similar one line statements together.

    ```julia
    # Yes:
    foo = 1
    bar = 2
    baz = 3

    # No:
    foo = 1

    bar = 2

    baz = 3
    ```

- Use blank-lines to separate different multi-line blocks.

    ```julia
    # Yes:
    if foo
        println("Hi")
    end

    for i in 1:10
        println(i)
    end

    # No:
    if foo
        println("Hi")
    end
    for i in 1:10
        println(i)
    end
    ```
- After a function definition, and before an end statement do not include a blank line.

    ```julia
    # Yes:
    function foo(bar::Int64, baz::Int64)
        return bar + baz
    end

    # No:
    function foo(bar::Int64, baz::Int64)

        return bar + baz
    end

    # No:
    function foo(bar::In64, baz::Int64)
        return bar + baz

    end
    ```

- Use line breaks between control flow statements and returns.

    ```julia
    # Yes:
    function foo(bar; verbose = false)
        if verbose
            println("baz")
        end

        return bar
    end

    # Ok:
    function foo(bar; verbose = false)
        if verbose
            println("baz")
        end
        return bar
    end
    ```

### NamedTuples

The `=` character in `NamedTuple`s should be spaced as in keyword arguments. Space should be put between the name and its value. The empty `NamedTuple` should be written `NamedTuple()` not `(;)`

```julia
# Yes:
xy = (x = 1, y = 2)
x = (x = 1,)  # Trailing comma required for correctness.
x = (; kwargs...)  # Semicolon required to splat correctly.

# No:
xy = (x=1, y=2)
xy = (;x=1,y=2)
```

### Numbers

- Floating-point numbers should always include a leading and/or trailing zero:

```julia
# Yes:
0.1
2.0
3.0f0

# No:
.1
2.
3.f0
```

- Always prefer the type `Int` to `Int32` or `Int64` unless one has a specific reason to choose the bit size.

### Ternary Operator

Ternary operators (`?:`) should generally only consume a single line. Do not chain multiple ternary operators. If chaining many conditions, consider using an `if`-`elseif`-`else` conditional, dispatch, or a dictionary.

```julia
# Yes:
foobar = foo == 2 ? # Yes:
foobar = foo == 2 ?
    bar :
    baz
foobar = foo == 2 ? bar : foo == 3 ? qux : baz
```

As an alternative, you can use a compound boolean expression:

```julia
# Yes:
foobar = if foo == 2
    bar
else
    baz
end

foobar = if foo == 2
    bar
elseif foo == 3
    qux
else
    baz
end
```

### For loops

For loops should always use `in`, never `=` or `∈`. This also applies to list and generator comprehensions

```julia
# Yes
for i in 1:10
    #...
end

[foo(x) for x in xs]

# No:
for i = 1:10
    #...
end

[foo(x) for x ∈ xs]
```

### Function Type Annotations

Annotations for function definitions should be as general as possible.

```julia
# Yes:
splicer(arr::AbstractArray, step::Integer) = arr[begin:step:end]

# No:
splicer(arr::Array{Int}, step::Int) = arr[begin:step:end]
```

Using as many generic types as possible allows for a variety of inputs and allows your code to be more general:

```julia
julia> splicer(1:10, 2)
1:2:9

julia> splicer([3.0, 5, 7, 9], 2)
2-element Array{Float64,1}:
 3.0
 7.0
```

### Struct Type Annotations

Annotations on type fields need to be given a little more thought, since field access is not concrete unless the compiler can infer the type (see [type-dispatch design](https://www.stochasticlifestyle.com/type-dispatch-design-post-object-oriented-programming-julia/) for details). Since well-inferred code is preferred, abstract type annotations, i.e.

```julia
mutable struct MySubString <: AbstractString
    string::AbstractString
    offset::Integer
    endof::Integer
end
```

are not recommended. Instead a concretely-typed struct:

```julia
mutable struct MySubString <: AbstractString
    string::String
    offset::Int
    endof::Int
end
```

is preferred. If generality is required, then parametric typing is preferred, i.e.:

```julia
mutable struct MySubString{T<:Integer} <: AbstractString
    string::String
    offset::T
    endof::T
end
```

Untyped fields should be explicitly typed `Any`, i.e.:

```julia
struct StructA
    a::Any
end
```

### Macros

- Do not add spaces between assignments when there are multiple assignments.

```julia
Yes:
@parameters a = b
@parameters a=b c=d

No:
@parameters a = b c = d
```

### Types and Type Annotations

- Avoid elaborate union types. `Vector{Union{Int,AbstractString,Tuple,Array}}` should probably be `Vector{Any}`. This will reduce the amount of extra strain on compilation checking many branches.
- Unions should be kept to two or three types only for branch splitting. Unions of three types should be kept to a minimum for compile times.
- Do not use `===` to compare types. Use `isa` or `<:` instead.

### Package version specifications

- Use [Semantic Versioning](https://semver.org/)
- For simplicity, avoid including the default caret specifier when specifying package version requirements.

```julia
# Yes:
DataFrames = "0.17"

# No:
DataFrames = "^0.17"
```

- For accuracy, do not use constructs like `>=` to avoid upper bounds.
- Every dependency should have a bound.
- All packages should use [CompatHelper](https://github.com/JuliaRegistries/CompatHelper.jl) and attempt to stay up to date with the dependencies.
- The lower bound on dependencies should be the last tested version.

### 文档

- 文档编写应始终追求最高水平。 换言之，倾向于编写一个适用于所有方法的接口文档，而不是为每个方法都编写文档，倾向于为抽象类型编写接口文档，而不是为每个子类型都编写文档。 所有实例应该引用更高层级的文档。
- 文档应该使用 [Document.jl](https://juliadocs.github.io/Documenter.jl/stable/)  来构建。
- 教程应该写在参考材料之前。
- 每个包都应该有一个入门教程，能够涵盖“90%的用例”，即大多数人会想要使用包的方式。
- The tutorial should show a complete workflow and be opinionated about said workflow. For example, when writing a tutorial about a simulator, pick a plotting package and show how to plot it.
- Variable names in tutorials are important. If you use `u0`, then all other codes will copy that naming scheme. Show potential users the right way to use your code with the right naming.
- When applicable, tutorials on how to use the "high performance advanced features" should be separated from the beginning tutorial.
- All documentation should summarize the contents before going into specifics of API docstrings.
- Most modules, types and functions should have [docstrings](http://docs.julialang.org/en/v1/manual/documentation/).
- Prefer documenting accessor functions instead of fields when possible. Documented fields are part of the public API and changing their contents/name constitutes a breaking change.
- Only exported functions are required to be documented.
- Avoid documenting commonly overloaded methods, such as `==`.
- Try to document a function and not individual methods where possible, as typically all methods will have similar docstrings.
- If you are adding a method to a function that already has a docstring only add a docstring if the behavior of your function deviates from the existing docstring.
- Docstrings are written in [Markdown](https://en.wikipedia.org/wiki/Markdown) and should be concise.
- Docstring lines should be wrapped at 92 characters.

```julia
"""
    bar(x[, y])

Compute the Bar index between `x` and `y`. If `y` is missing, compute the Bar index between
all pairs of columns of `x`.
"""
function bar(x, y) ...
```

- It is recommended that you have a blank line between the headings and the content when the content is of sufficient length.
- Try to be consistent within a docstring whether you use this additional whitespace.
- Follow one of the following templates for types and functions when possible:

Type Template (should be skipped if it is redundant with the constructor(s) docstring):

```julia
"""
    MyArray{T, N}

My super awesome array wrapper!

# Fields
- `data::AbstractArray{T, N}`: stores the array being wrapped
- `metadata::Dict`: stores metadata about the array
"""
struct MyArray{T, N} <: AbstractArray{T, N}
    data::AbstractArray{T, N}
    metadata::Dict
end
```

Function Template (only required for exported functions):

```julia
"""
    mysearch(array::MyArray{T}, val::T; verbose = true) where {T} -> Int

Searches the `array` for the `val`. For some reason we don't want to use Julia's
builtin search :)

# Arguments
- `array::MyArray{T}`: the array to search
- `val::T`: the value to search for

# Keywords
- `verbose::Bool = true`: print out progress details

# Returns
- `Int`: the index where `val` is located in the `array`

# Throws
- `NotFoundError`: I guess we could throw an error if `val` isn't found.
"""
function mysearch(array::AbstractArray{T}, val::T) where {T}
    ...
end
```

- The `@doc doc""" """` formulation from the Markdown standard library should be used whenever there is LaTeX.
- Only public fields of types must be documented. Undocumented fields are considered non-public internals.
- If your method contains lots of arguments or keywords, you may want to exclude them from the method signature on the first line and instead use `args...` and/or `kwargs...`.

```julia
"""
    Manager(args...; kwargs...) -> Manager

A cluster manager which spawns workers.

# Arguments

- `min_workers::Integer`: The minimum number of workers to spawn or an exception is thrown
- `max_workers::Integer`: The requested number of workers to spawn

# Keywords

- `definition::AbstractString`: Name of the job definition to use. Defaults to the
    definition used within the current instance.
- `name::AbstractString`: ...
- `queue::AbstractString`: ...
"""
function Manager(...)
    ...
end
```

- Feel free to document multiple methods for a function within the same docstring. Be careful to only do this for functions you have defined.

```julia
"""
    Manager(max_workers; kwargs...)
    Manager(min_workers:max_workers; kwargs...)
    Manager(min_workers, max_workers; kwargs...)

A cluster manager which spawns workers.

# Arguments

- `min_workers::Int`: The minimum number of workers to spawn or an exception is thrown
- `max_workers::Int`: The requested number of workers to spawn

# Keywords

- `definition::AbstractString`: Name of the job definition to use. Defaults to the
    definition used within the current instance.
- `name::AbstractString`: ...
- `queue::AbstractString`: ...
"""
function Manager end

```

- If the documentation for bullet-point exceeds 92 characters, the line should be wrapped and slightly indented. Avoid aligning the text to the `:`.

```julia
"""
...

# Keywords
- `definition::AbstractString`: Name of the job definition to use. Defaults to the
    definition used within the current instance.
"""
```

### 报错处理

- `error("string")` 应予避免。 首选是定义和抛出异常类型。 请参阅[有关异常的文档，以获取更多详细信息](https://docs.julialang.org/en/v1/manual/control-flow/#Exception-Handling)。
- 尝试避免使用 `try/catch`。 Use it as minimally as possible. 应该在运行代码之前就处理好潜在问题。

### 数组

- 尽可能避免使用 splating 语法（`...`）。 优先使用迭代器，如 `collect`、 `vcat`、 `hcat` 等。

### 行尾

总是遵循 Unix 风格在代码最后一行添加 `\n`。

### VS-Code 配置

如果您用的是 VS Code，那么我们推荐您在 Julia 格式化设置中添加以下代码。 要使用这些设置，请使用快捷键 <kbd>CMD</kbd>+<kbd>,</kbd> （Mac OS）或 <kbd>CTRL</kbd>+<kbd>,</kbd> （其它系统）打开你的 VS Code 设置，然后将以下代码添加至 `settings.json` 中：

```json
{
    "[julia]": {
        "editor.detectIndentation": false,
        "editor.insertSpaces": true,
        "editor.tabSize": 4,
        "files.insertFinalNewline": true,
        "files.trimFinalNewlines": true,
        "files.trimTrailingWhitespace": true,
        "editor.rulers": [92],
        "files.eol": "\n"
    },
}
```
此外，您可能会发现 [Julia VS-Code 拓展](https://github.com/julia-vscode/julia-vscode) 很有用。

### JuliaFormatter

**注意：** `sciml` **风格只在 ** `JuliaFormatter v1.0` **或更高版本中可用**

添加以下内容到 `.JuliaFormatter.toml`
```toml
style = "sciml"
```
并在仓库根目录下运行
```julia
using JuliaFormatter, SomePackage
format(joinpath(dirname(pathof(SomePackage)), ".."))
```
得以自动格式化软件包代码

添加 [FormatCheck.yml](https://github.com/SciML/ModelingToolkit.jl/blob/master/.github/workflows/FormatCheck.yml) 来启用 CI 格式化检测。  当代码不符合风格规范时，CI 会失败。 因此，在提交之前应该先执行 `格式化`。

# 参考

本文许多准则参考自 [Julia style guide](https://docs.julialang.org/en/v1/manual/style-guide/)，[YASGuide](https://github.com/jrevels/YASGuide)，以及 [Blue style guide](https://github.com/invenia/BlueStyle#module-imports).
